> 主要针对于方法

# 模板模式

> 模板模式,在一个抽象公开定义执行它的方法的模板。它的子类可以按照需求重写方法实现
>
> 模板模式定义一个操作算法的骨架,而将一些步骤延迟到子类,使得子类可以改变算法的结构,重新定义一些特定的步骤

> 以豆浆的制作流程为例子

## UML

![image-20200616152353597](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200616152353597.png)

## 代码实现

```java
//表示豆浆的抽象类
public abstract  class SoyaMilk {

    public void make(){
       select();
       if(customerWantCondiments()) {
           addCondiments();
       }
       soak();
    }

    public void select(){
        System.out.println("选择好的新鲜黄豆");
    }
    public abstract void addCondiments();

    public void soak(){
        System.out.println("黄豆和配料开始浸泡");
    }

    //钩子方法,子类自定义是否需要改变它实现不同的方法
    boolean customerWantCondiments(){
        return true;
    }
}

public class RedBeanSoyaMilk extends SoyaMilk {

    @Override
    public void addCondiments() {
        System.out.println("加入红豆,制作红豆豆浆");
    }
}

public class PeanutSoyaMilk extends SoyaMilk {

    @Override
    public void addCondiments() {
        System.out.println("加入花生,制作花生豆浆");
    }

    @Override
    boolean customerWantCondiments() {
        return false;
    }
}

public class Client {
    public static void main(String[] args) {
        SoyaMilk peanutSoyaMilk =new PeanutSoyaMilk();
        peanutSoyaMilk.make();

        System.out.println("=========================");

        SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk();
        redBeanSoyaMilk.make();
    }
}
```

## 源码分析

### UML

![image-20200617201705807](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200617201705807.png)

### 代码实现

```java
// 在SpringIOC中的ConfigurableApplicationContext
public interface ConfigurableApplicationContext extends ApplicationContext, Lifecycle, Closeable {
    refresh();//实现了模板方法
}
//ConfigurableApplicationContext的继承类
public abstract class AbstractApplicationContext extends DefaultResourceLoader
		implements ConfigurableApplicationContext, DisposableBean {
@Override
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
            //注意:这个方法里面是抽象方法
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
                //这个是一个空方法,相当于是钩子方法
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
                //这个也是一个钩子方法
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}
		}
	}
}
```

# 命令模式

> 命令模式可以将动作的请求者和动作的执行者解耦出来
>
> 例子:我们买了一套只能家具,照明灯,洗衣机，电视。。。我们只要在手机上装APP就可以控制这些家电工作了。但是这些家电来自不同的厂商需要下载多个APP

> 便于理解：将军发号命令让士兵发动进攻,并不是直接一个个通知士兵的,而是有一个命令的传达者,士兵接收到命令之后发起进攻。

## UML类图

![image-20200617211251380](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200617211251380.png)

## 例子

### UML类图

![image-20200617212619229](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200617212619229.png)

### 代码演示

```java
public interface  Command {
    //执行
    public void execute();
    //撤销
    public void undo();
}

public class LightReceiver {

    public void on(){
        System.out.println("打开了灯的遥控器");
    }

    public void off(){
        System.out.println("关闭了灯的遥控器");
    }
}

public class LightOffCommand implements Command {

    private LightReceiver lightReceiver;

    public LightOffCommand(LightReceiver lightReceiver){
        this.lightReceiver = lightReceiver;
    }

    @Override
    public void execute() {
        lightReceiver.off();
    }

    @Override
    public void undo() {
        lightReceiver.on();
    }
}

public class LightOnCommand implements Command{

    private LightReceiver lightReceiver;

    public LightOnCommand(LightReceiver lightReceiver){
        this.lightReceiver = lightReceiver;
    }

    @Override
    public void execute() {
        lightReceiver.on();
    }

    @Override
    public void undo() {
        lightReceiver.off();
    }
}

public class NoCommand implements Command {

    @Override
    public void execute() {

    }

    @Override
    public void undo() {

    }
}

public class RemoteController {

    private Command[] onCommands;
    private Command[] offCommands;

    //撤销
    Command undoCommand;

    public RemoteController() {
        onCommands = new Command[5];
        offCommands = new Command[5];

        for (int i = 0; i < 5; i++) {
            //初始的时候 什么都不执行
            onCommands[i] = new NoCommand();
            offCommands[i] = new NoCommand();
        }
    }

    public void setCommand(int no, Command onCommand, Command offCommand) {
        onCommands[no] = onCommand;
        offCommands[no] = offCommand;
    }

    //按下打开按钮
    public void onButtonWasPushed(int no) {
        onCommands[no].execute();
        //记录这次操作,用于撤销
        undoCommand = onCommands[no];
    }

    //按下关闭按钮
    public void offButtonWasPushed(int no){
        offCommands[no].execute();
        //记录这次操作,用于撤销
        undoCommand = offCommands[no];
    }

    //按下撤销按钮
    public void undoButtonWashPushed(){
        undoCommand.undo();
    }
}

public class Client {
    public static void main(String[] args) {
        LightReceiver lightReceiver = new LightReceiver();

        Command onCommand = new LightOnCommand(lightReceiver);
        Command offCommand = new LightOffCommand(lightReceiver);

        RemoteController remoteController = new RemoteController();
        remoteController.setCommand(0,onCommand,offCommand);

        remoteController.onButtonWasPushed(0);
        remoteController.offButtonWasPushed(0);
        remoteController.undoButtonWashPushed();

    }
}

```

## 源码分析

> 在Spring框架中的JdbcTemplate就使用到了命令模式

```java
jdbcTemplate中的
@Override
	public void execute(final String sql) throws DataAccessException {
		if (logger.isDebugEnabled()) {
			logger.debug("Executing SQL statement [" + sql + "]");
		}
		class ExecuteStatementCallback implements StatementCallback<Object>, SqlProvider {
			@Override
			public Object doInStatement(Statement stmt) throws SQLException {
				stmt.execute(sql);
				return null;
			}
			@Override
			public String getSql() {
				return sql;
			}
		}
		execute(new ExecuteStatementCallback());
	}

//这个StatementCallback是一个接口,类似于接口命令
//class ExecuteStatementCallback implements StatementCallback<Object>, SqlProvider
//即实现了命令接口也实现了命令接收者
//调用者是jdbcTemplate
```

# 访问者模式

> 访问者模式：封装一些作用于数据结构的各元素的操作,它可以在不改变数据结构的前提下定义作用于这些元素的操作。

> 访问者模式的角色以及职责:
>
>   Visitor:是抽象访问者，为该对象结构中的ConcreteElement的每一个类声明visitor的操作
>
>   ConcreteVisitor:是一个具体的访问者,实现每一个的visitor声明操作,是每个操作的具体实现
>
>   ObjectStructure:能枚举它的元素,可以提供一个高层的接口，用来允许访问者访问元素
>
>  Element定义一个accept方法,接收访问者对象
>
>  ConCreteElement为具体的元素,实现了accept
>
> ==简而言之就是形成一个环形的闭合通道==



![image-20200618232654137](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200618232654137.png)

## UML类图

![image-20200619072053106](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200619072053106.png)



## 代码

```java
public interface Visitor {
    void visitCpu(CPU cpu);
    void visitMemory(Memory memory);
    void visitBoard(Board board);
}

public class PersonalVisitor implements Visitor {

    double totalPrice=0.0;

    @Override
    public void visitCpu(CPU cpu) {
        totalPrice += cpu.getPrice()*0.9;
        System.out.println(totalPrice);
    }

    @Override
    public void visitMemory(Memory memory) {
        totalPrice+=memory.getPrice()*0.9;
    }

    @Override
    public void visitBoard(Board board) {
        totalPrice+=board.getPrice()*0.9;
    }
}

public abstract class ComputerPart {
    abstract void accept(Visitor v);

    abstract double getPrice();
}

public class CPU extends ComputerPart {

    @Override
    void accept(Visitor v) {
        v.visitCpu(this);
    }

    @Override
    double getPrice() {
        return 500;
    }
}

public class Memory extends ComputerPart {

    @Override
    void accept(Visitor v) {
        v.visitMemory(this);
    }

    @Override
    double getPrice() {
        return 300;
    }
}

public class Board extends ComputerPart {

    @Override
    void accept(Visitor v) {
        v.visitBoard(this);
    }

    @Override
    double getPrice() {
        return 700;
    }
}

public class ObjectStructure {

    private List<ComputerPart> computerParts = new ArrayList<>();

    //增加到list
    public void attach(ComputerPart p) {
        computerParts.add(p);
    }
    //移除
    public void detach(ComputerPart p) {
        computerParts.remove(p);
    }

    //显示测评情况
    public void display(Visitor action) {
        for(ComputerPart p: computerParts) {
            p.accept(action);
        }
    }
}

public class Computer {
    ComputerPart cpu = new CPU();
    ComputerPart memory = new Memory();
    ComputerPart board = new Board();

    public void accept(Visitor v){
        this.cpu.accept(v);
        this.memory.accept(v);
        this.board.accept(v);
    }

    public static void main(String[] args) {
        PersonalVisitor p = new PersonalVisitor();
        new Computer().accept(p);
        System.out.println(p.totalPrice);

        ObjectStructure objectStructure = new ObjectStructure();
        PersonalVisitor personalVisitor = new PersonalVisitor();
        objectStructure.attach(new CPU());
        objectStructure.display(personalVisitor);

    }
}
```

# 迭代器模式

> 如果集合是用不同的方式实现的,如集合,数组等。这时候使用一致的方式提供统一的接口

## UML类图

![image-20200622073150411](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200622073150411.png)

## 代码

```java
public class Department {

    private String name;

    private String desc;

    public Department(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }
}

public class ComputerCollegeIterator implements Iterator {

    Department[] department;
    int position = 0;

    public ComputerCollegeIterator(Department[] department){
        this.department = department;
    }

    @Override
    public boolean hasNext() {
        if(position>department.length || department[position]==null){
            return  false;
        }
        return true;
    }

    @Override
    public Object next() {
        Department department = this.department[position];
        position+=1;
        return department;
    }
}

public  class InfoCollegeIterator implements Iterator {

    List<Department> departments;
    int index = 0;

    public InfoCollegeIterator(List<Department> departments){
        this.departments = departments;
    }

    @Override
    public boolean hasNext() {
        if(index>departments.size()-1){
            return false;
        }
        return true;
    }

    @Override
    public Object next() {
        Department department = departments.get(index);
        index+=1;
        return department;
    }

    @Override
    public void remove() {

    }
}

public interface College {

    public  String getName();

    public void addDepartment(String name,String desc);

    public Iterator createIterator();
}

public class ComputerCollege implements College{

    private Department[] departments;
    int index = 0;

    public ComputerCollege(){
        departments =new Department[5];
        addDepartment("Java专业", " Java专业 ");
        addDepartment("PHP专业", " PHP专业 ");
        addDepartment("大数据专业", " 大数据专业 ");
    }

    @Override
    public String getName() {
        return "计算机学院";
    }

    @Override
    public void addDepartment(String name, String desc) {
        Department department = new Department(name,desc);
        departments[index] =department;
        index++;
    }

    @Override
    public Iterator createIterator() {
        return new ComputerCollegeIterator(departments);
    }
}

public class InfoCollege implements College {

    List<Department> departments;

    public InfoCollege(){
        departments = new ArrayList<>();
        addDepartment("信息安全专业", " 信息安全专业 ");
        addDepartment("网络安全专业", " 网络安全专业 ");
        addDepartment("服务器安全专业", " 服务器安全专业 ");
    }

    @Override
    public String getName() {
        return "信息技术学院";
    }

    @Override
    public void addDepartment(String name, String desc) {
        Department department = new Department(name,desc);
        departments.add(department);
    }

    @Override
    public Iterator createIterator() {
        return new InfoCollegeIterator(departments);
    }
}

public class OutputImpl {
    //得到所有学院
    private List<College> colleges;

    public OutputImpl(List<College> colleges){
        this.colleges = colleges;
    }

    //遍历所有学院,然后调用printDepartment 输出各个学院的系
    public void printCollege() {
        Iterator<College> iterator = colleges.iterator();
        while(iterator.hasNext()){
            College college = iterator.next();
            System.out.println("=== "+college.getName() +"=====" );
            printDepartment(college.createIterator()); //得到对应迭代器
        }
    }

    private void printDepartment(Iterator iterator) {
        while (iterator.hasNext()){
            Department d = (Department) iterator.next();
            System.out.println(d.getName());
        }
    }
}

public class Client {
    public static void main(String[] args) {
        College  computerCollege= new ComputerCollege();
        College infoCollege = new InfoCollege();

        List<College> colleges = new ArrayList<>();
        colleges.add(computerCollege);
        colleges.add(infoCollege);

        OutputImpl output = new OutputImpl(colleges);
        output.printCollege();
    }
}

```

## 源码分析

### UML图

![image-20200622074337735](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200622074337735.png)

### 代码

```java
//ArrayList
public Iterator<E> iterator() {
        return new Itr();
}
transient Object[] elementData;
E elementData(int index) {
        return (E) elementData[index];
}
//ArrayList的内部类 实现了Iterator
private class Itr implements Iterator<E> {
    
}
```

# 观察者模式

> 以集合的方式来管理用户，包括注册移除和通知

> 以天气预报为一个例子来分析观察者模式

## 传统模式的代码

```java
public class CurrentConditions {

    // 温度，气压，湿度
    private float temperature;
    private float pressure;
    private float humidity;

    //更新 天气情况，是由 WeatherData 来调用，我使用推送模式
    public void update(float temperature, float pressure, float humidity) {
        this.temperature = temperature;
        this.pressure = pressure;
        this.humidity = humidity;
        display();
    }

    //显示
    public void display() {
        System.out.println("***Today mTemperature: " + temperature + "***");
        System.out.println("***Today mPressure: " + pressure + "***");
        System.out.println("***Today mHumidity: " + humidity + "***");
    }
}

public class WeatherData {
    //温度
    private float temperature;
    private float pressure;
    private float humidity;
    private CurrentConditions currentConditions;

    public WeatherData(CurrentConditions currentConditions) {
        this.currentConditions = currentConditions;
    }

    public float getTemperature() {
        return temperature;
    }

    public float getPressure() {
        return pressure;
    }

    public float getHumidity() {
        return humidity;
    }

    public void dataChange(){
        currentConditions.update(getTemperature(),getPressure(),getHumidity());
    }

    public void setData(float temperature, float pressure, float humidity){
        this.temperature = temperature;
        this.pressure = pressure;
        this.humidity = humidity;

        dataChange();
    }
}

public class Client {
    public static void main(String[] args) {
        CurrentConditions currentConditions = new CurrentConditions();
        WeatherData weatherData = new WeatherData(currentConditions);
        weatherData.setData(30,150,40);
    }
}
```

## 使用观察者模式

### UML类图

![image-20200623220642819](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200623220642819.png)

### 代码

```java
public interface Observer {
    public void update(float temperature,float pressure,float humidity);
}

public class CurrentCondition implements Observer{

    private float temperature;
    private float pressure;
    private float humidity;

    @Override
    public void update(float temperature, float pressure, float humidity) {
        this.temperature = temperature;
        this.pressure =pressure;
        this.humidity =humidity;
        display();
    }

    //显示
    public void display() {
        System.out.println("***Today mTemperature: " + temperature + "***");
        System.out.println("***Today mPressure: " + pressure + "***");
        System.out.println("***Today mHumidity: " + humidity + "***");
    }
}

public interface Subject {

    void addObserver(Observer observer);

    void removeObserver(Observer observer);

    void notifyObservers();
}

public class WeatherData implements Subject {

    private float temperature;
    private float pressure;
    private float humidity;
    List<Observer> observers;

    public void dataChange(){
        notifyObservers();
    }

    public void setData(float temperature, float pressure, float humidity){
        this.temperature = temperature;
        this.pressure = pressure;
        this.humidity =humidity;
        dataChange();
    }

    public WeatherData(){
        observers  = new ArrayList<>();
    }

    @Override
    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(temperature,pressure,humidity);
        }
    }
}

public class Client {
    public static void main(String[] args) {
        WeatherData weatherData = new WeatherData();
        Observer observer = new CurrentCondition();
        weatherData.addObserver(observer);
        weatherData.setData(10f, 100f, 30.3f);
    }
}
```

## 源码分析

```java
public interface Observer {
    /**
     * This method is called whenever the observed object is changed. An
     * application calls an <tt>Observable</tt> object's
     * <code>notifyObservers</code> method to have all the object's
     * observers notified of the change.
     *
     * @param   o     the observable object.
     * @param   arg   an argument passed to the <code>notifyObservers</code>
     *                 method.
     */
    void update(Observable o, Object arg);
}

public class Observable {
    private boolean changed = false;
    private Vector<Observer> obs;
    
    //实现了添加
    public synchronized void addObserver(Observer o) {}
    //实现了删除
    public synchronized void deleteObserver(Observer o) {
        obs.removeElement(o);
    }
    //实现了通知
    public void notifyObservers() {
        notifyObservers(null);
    }
}
```

> Observable的地位等价于我们之前的Subject方法
>
> Observable是类不是接口,类中已经实现了核心的方法,即管理Observer的方法的add delete notify
>
> Observer等价于我们之前讲过的Observer

# 中介者模式

> 用一个中介对象来封装一系列的对象交互,中介者使各个对象不需要显示的相互引用，从而使其耦合松散，且可以独立的改变他们之间的交互

## UML类图

![image-20200624074404155](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200624074404155.png)

## 代码

```java
public abstract class Mediator {
    //将给中介者对象加入到集合中
    public abstract void register(String colleagueName,Colleague colleague);

    //接收消息 具体的同事对象发出
    public abstract void getMessage(int stateChange,String colleagueName);

    public abstract void sendMessage();
}

public abstract class Colleague {
     Mediator mediator;
     String name;

    public Colleague(Mediator mediator,String name){
        this.mediator = mediator;
        this.name = name;
    }

    public Mediator getMediator(){
        return this.mediator;
    }

    public abstract void sendMessage(int stateChange);
}

public class ConcreteMediator extends Mediator {
    //集合，放入所有的同事对象
    private HashMap<String, Colleague> colleagueMap;
    private HashMap<String, String> interMap;

    public ConcreteMediator(){
        colleagueMap = new HashMap<String, Colleague>();
        interMap = new HashMap<String, String>();
    }

    @Override
    public void register(String colleagueName, Colleague colleague) {
        colleagueMap.put(colleagueName,colleague);
        if(colleague instanceof Alarm){
            interMap.put("Alarm",colleagueName);
        }else if(colleague instanceof CoffeeMachine){
            interMap.put("CoffeeMachine",colleagueName);
        }else if (colleague instanceof TV) {
            interMap.put("TV", colleagueName);
        } else if (colleague instanceof Curtains) {
            interMap.put("Curtains", colleagueName);
        }
    }

    //具体中介者的核心方法
    //1. 根据得到消息，完成对应任务
    //2. 中介者在这个方法，协调各个具体的同事对象，完成任务
    @Override
    public void getMessage(int stateChange, String colleagueName) {
        if (colleagueMap.get(colleagueName) instanceof Alarm) {
            if(stateChange==0){
                ((CoffeeMachine)colleagueMap.get(interMap.get("CoffeeMachine"))).startCoffee();
                ((TV) (colleagueMap.get(interMap.get("TV")))).startTv();
            } else if (stateChange == 1) {
                ((TV) (colleagueMap.get(interMap.get("TV")))).stopTv();
            }
        }else if (colleagueMap.get(colleagueName) instanceof CoffeeMachine) {
            ((Curtains) (colleagueMap.get(interMap.get("Curtains"))))
                    .upCurtains();

        } else if (colleagueMap.get(colleagueName) instanceof TV) {//如果TV发现消息

        } else if (colleagueMap.get(colleagueName) instanceof Curtains) {
            //如果是以窗帘发出的消息，这里处理...
        }
    }

    @Override
    public void sendMessage() {

    }
}

public class Alarm extends Colleague {

    public Alarm(Mediator mediator, String name) {
        super(mediator, name);
        mediator.register(name,this);
    }

    @Override
    public void sendMessage(int stateChange) {
        this.getMediator().getMessage(stateChange,name);
    }

    public void sendAlarm(int stateChange){
        sendMessage(stateChange);
    }
}

public class CoffeeMachine extends Colleague {

    public CoffeeMachine(Mediator mediator, String name) {
        super(mediator, name);
        mediator.register(name,this);
    }

    @Override
    public void sendMessage(int stateChange) {
        this.getMediator().getMessage(stateChange,this.name);
    }

    public void startCoffee() {
        System.out.println("It's time to startcoffee!");
    }

    public void FinishCoffee() {

        System.out.println("After 5 minutes!");
        System.out.println("Coffee is ok!");
        sendMessage(0);
    }
}

public class Curtains extends Colleague {

    public Curtains(Mediator mediator, String name) {
        super(mediator, name);
        mediator.register(name,this);
    }

    @Override
    public void sendMessage(int stateChange) {
        this.getMediator().getMessage(stateChange, this.name);
    }

    public void upCurtains() {
        System.out.println("I am holding Up Curtains!");
    }
}

public class TV extends Colleague {

    public TV(Mediator mediator, String name) {
        super(mediator, name);
        mediator.register(name,this);
    }

    @Override
    public void sendMessage(int stateChange) {
      this.getMediator().getMessage(stateChange,name);
    }

    public void startTv() {
        // TODO Auto-generated method stub
        System.out.println("It's time to StartTv!");
    }

    public void stopTv() {
        // TODO Auto-generated method stub
        System.out.println("StopTv!");
    }
}

public class Client {
    public static void main(String[] args) {
        Mediator mediator = new ConcreteMediator();
        //创建一个Alarm
        Alarm alarm = new Alarm(mediator,"Alarm");
        //创建一个CofferMachine
        CoffeeMachine coffeeMachine = new CoffeeMachine(mediator, "CoffeeMachine");
        //创建 Curtains , 并  且加入到  ConcreteMediator 对象的HashMap
        Curtains curtains = new Curtains(mediator, "curtains");
        TV tV = new TV(mediator, "TV");

        //让闹钟发出消息
        alarm.sendAlarm(0);
        coffeeMachine.FinishCoffee();
        alarm.sendAlarm(1);
    }
}
```

# 备忘录模式

> 在不破坏封装的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态。这样就可以恢复到原先保存的状态

## UML

![image-20200624144605693](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200624144605693.png)

## 案例代码

```java
public class Originator {

    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public Memento saveMemento(){
        return new Memento(state);
    }

    public void getStateFromMemento(Memento memento){
        state = memento.getState();
    }
}

public class Memento {
    private String state;

    public Memento(String state){
        this.state = state;
    }

    public String getState() {
        return state;
    }
}

public class Caretaker {
    List<Memento> list = new ArrayList<>();

    public void add(Memento  memento){
        list.add(memento);
    }

    public Memento get(int index){
        return list.get(index);
    }
}

public class Clinet {
    public static void main(String[] args) {
        Originator originator = new Originator();
        originator.setState(" 状态#1 攻击力 100 ");
        Caretaker caretaker = new Caretaker();
        caretaker.add(originator.saveMemento());
        originator.setState(" 状态#2 攻击力 80 ");
        caretaker.add(originator.saveMemento());
        originator.setState(" 状态#3 攻击力 60 ");
        caretaker.add(originator.saveMemento());

        System.out.println("当前的状态是 =" + originator.getState());

        Memento memento = caretaker.get(0);
        originator.getStateFromMemento(memento);
        System.out.println("当前的状态是 =" +originator.getState());
    }
}

```



# 解释器模式

> 指定一个语言表达式,定义它的一种文法，并且定义一个解释器使用该解释器释放语言中的句子
>
> 解释器模式应用在：编译器，运算表达式计算，正则表达式

## UML类图

![image-20200625162724694](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200625162724694.png)

## 代码

```java
/**
 * 抽象类表达式 通过hashmap键值对 可获取变量的值
 */
public abstract class Expression {

    /**
     * a+b+c
     * 解释公式的数值,key就是公式(表达式) 参数【a,b,c】 value就是具体的值
     * Hashmap{a=10,b=20}
     * @param var
     * @return
     */
    public abstract int interpreter(HashMap<String,Integer> var);
}

/**
 * 变量的解析器:
 */
public class VarExpression extends  Expression {

    //key=a,key=b,key=c
    private String key;

    public VarExpression(String key){
        this.key = key;
    }

    /**
     * @param var
     * @return
     * 根据变量的名称 返回对应的值
     */
    @Override
    public int interpreter(HashMap<String, Integer> var) {
        return var.get(key);
    }
}

/**
 * 抽象的运算符号解析器,每个运算符都有自己左右两个数字有关系
 * 但左右两个数字有可能也是一个解析的结果，无论何种类型，都是Expression的实现类
 */
public abstract class SymbolExpression extends Expression {

    protected Expression left;
    protected Expression right;


    public SymbolExpression(Expression left,Expression right){
        this.left = left;
        this.right = right;
    }


    @Override
    public int interpreter(HashMap<String, Integer> var) {
        return 0;
    }
}

/**
 * 加法解析器
 */
public class AddExpression extends SymbolExpression {

    public AddExpression(Expression left, Expression right) {
        super(left, right);
    }

    /**
     * 返回符号左边的数值+返回符号右边的数值
     * @param var
     * @return
     */
    @Override
    public int interpreter(HashMap<String, Integer> var) {
        return super.left.interpreter(var)+super.right.interpreter(var);
    }
}

public class SubExpression extends SymbolExpression {

    public SubExpression(Expression left, Expression right) {
        super(left, right);
    }

    /**
     * 返回符号左边的数值-返回符号右边的数值
     * @param var
     * @return
     */
    @Override
    public int interpreter(HashMap<String, Integer> var) {
        return super.left.interpreter(var)-super.right.interpreter(var);
    }
}

public class Calculator {

    private Expression expression;

    //构造函数传参,并解析
    public Calculator(String expStr){//a+b
        //安排运算的先后顺序
        Stack<Expression> stack = new Stack<>();
        char[] charsArray = expStr.toCharArray();

        Expression left = null;
        Expression right = null;
        for(int i=0 ;i<charsArray.length;i++){
            switch (charsArray[i]){ //a+b+c
                case '+':
                    left=stack.pop();
                    right=new VarExpression(String.valueOf(charsArray[++i]));
                    stack.push(new AddExpression(left,right));
                    break;
                case '-':
                    left=stack.pop();
                    right=new VarExpression(String.valueOf(charsArray[++i]));
                    stack.push(new SubExpression(left,right));
                    break;
                default:
                    stack.push(new VarExpression(String.valueOf(charsArray[i])));
                    break;
            }
        }
        this.expression = stack.pop();
    }

    public int run (HashMap<String,Integer> var){
        //将表达式和var绑定
        return this.expression.interpreter(var);
    }
}

public class Client {
    public static void main(String[] args) throws IOException {
        // TODO Auto-generated method stub
        String expStr = getExpStr(); // a+b
        HashMap<String, Integer> var = getValue(expStr);// var {a=10, b=20}
        Calculator calculator = new Calculator(expStr);
        System.out.println("运算结果：" + expStr + "=" + calculator.run(var));
    }

    // 获得表达式
    public static String getExpStr() throws IOException {
        System.out.print("请输入表达式：");
        return (new BufferedReader(new InputStreamReader(System.in))).readLine();
    }

    // 获得值映射
    public static HashMap<String, Integer> getValue(String expStr) throws IOException {
        HashMap<String, Integer> map = new HashMap<>();

        for (char ch : expStr.toCharArray()) {
            if (ch != '+' && ch != '-') {
                if (!map.containsKey(String.valueOf(ch))) {
                    System.out.print("请输入" + String.valueOf(ch) + "的值：");
                    String in = (new BufferedReader(new InputStreamReader(System.in))).readLine();
                    map.put(String.valueOf(ch), Integer.valueOf(in));
                }
            }
        }

        return map;
    }
}
```

## 源码

### UML

![image-20200625164922224](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200625164922224.png)

### 代码

```java
public class Interpreter {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//创建一个 Parser 对象
		SpelExpressionParser parser = new SpelExpressionParser();
		//
		//通过 Parser 对象 获取到一个Expression对象
		//会根据不同的  Parser 对象 ，返回不同的 Expression对象
		Expression expression = parser.parseExpression("10 * (2 + 1) * 1 + 66"); //96
		int result = (Integer) expression.getValue();
		System.out.println(result);
	}
}

public class SpelExpressionParser extends TemplateAwareExpressionParser {
    @Override
	protected SpelExpression doParseExpression(String expressionString, ParserContext context) throws ParseException {
		return new InternalSpelExpressionParser(this.configuration).doParseExpression(expressionString, context);
	}
}
//上面的类关联到这个类解析出SpelExpression供主程序使用
class InternalSpelExpressionParser extends TemplateAwareExpressionParser {
    @Override
	protected SpelExpression doParseExpression(String expressionString, ParserContext context) throws ParseException {
		try {
			this.expressionString = expressionString;
			Tokenizer tokenizer = new Tokenizer(expressionString);
			tokenizer.process();
			this.tokenStream = tokenizer.getTokens();
			this.tokenStreamLength = this.tokenStream.size();
			this.tokenStreamPointer = 0;
			this.constructedNodes.clear();
			SpelNodeImpl ast = eatExpression();
			if (moreTokens()) {
				throw new SpelParseException(peekToken().startpos,SpelMessage.MORE_INPUT,toString(nextToken()));
			}
			Assert.isTrue(this.constructedNodes.isEmpty());
			return new SpelExpression(expressionString, ast, this.configuration);
		}
		catch (InternalParseException ipe) {
			throw ipe.getCause();
		}
	}
}

public abstract class TemplateAwareExpressionParser implements ExpressionParser {
  	//根据不同的需要返回不同的Expression
    @Override
	public Expression parseExpression(String expressionString, ParserContext context)
			throws ParseException {
		if (context == null) {
			context = NON_TEMPLATE_PARSER_CONTEXT;
		}

		if (context.isTemplate()) {
			return parseTemplate(expressionString, context);
		}
		else {
			return doParseExpression(expressionString, context);
		}
	}
}
```



# 状态模式

> 状态模式:主要用来解决对象在多种状态转换时,需要对外输出不同的行为问题，状态和行为是一一对应的，状态之间可以相互转换。
>
> 当一个事件或者对象有多种状态,状态之前回相互转换,对不同状态有不同的行为时候,可以考虑使用状态模式

## UML图

![image-20200627151531159](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200627151531159.png)

## 代码

```java
/**
 * 状态抽象类
 *
 * @author Administrator
 */
public abstract class State {

    // 扣除积分 - 50
    public abstract void deductMoney();

    // 是否抽中奖品
    public abstract boolean raffle();

    // 发放奖品
    public abstract void dispensePrize();

}

public class RaffleActivity {

    // state 表示活动当前的状态，是变化
    State state = null;
    // 奖品数量
    int count = 0;

    // 四个属性，表示四种状态
    State noRafflleState = new NoRaffleState(this);
    State canRaffleState = new CanRaffleState(this);

    State dispenseState =   new DispenseState(this);
    State dispensOutState = new DispenseOutState(this);

    //构造器
    //1. 初始化当前的状态为 noRafflleState（即不能抽奖的状态）
    //2. 初始化奖品的数量
    public RaffleActivity( int count) {
        this.state = getNoRafflleState();
        this.count = count;
    }

    //扣分, 调用当前状态的 deductMoney
    public void debuctMoney(){
        state.deductMoney();
    }

    //抽奖
    public void raffle(){
        // 如果当前的状态是抽奖成功
        if(state.raffle()){
            //领取奖品
            state.dispensePrize();
        }

    }

    public State getState() {
        return state;
    }

    public void setState(State state) {
        this.state = state;
    }

    //这里请大家注意，每领取一次奖品，count--
    public int getCount() {
        int curCount = count;
        count--;
        return curCount;
    }

    public void setCount(int count) {
        this.count = count;
    }

    public State getNoRafflleState() {
        return noRafflleState;
    }

    public void setNoRafflleState(State noRafflleState) {
        this.noRafflleState = noRafflleState;
    }

    public State getCanRaffleState() {
        return canRaffleState;
    }

    public void setCanRaffleState(State canRaffleState) {
        this.canRaffleState = canRaffleState;
    }

    public State getDispenseState() {
        return dispenseState;
    }

    public void setDispenseState(State dispenseState) {
        this.dispenseState = dispenseState;
    }

    public State getDispensOutState() {
        return dispensOutState;
    }

    public void setDispensOutState(State dispensOutState) {
        this.dispensOutState = dispensOutState;
    }
}

public class NoRaffleState extends State{

    RaffleActivity activity;

    public NoRaffleState(RaffleActivity activity){
        this.activity= activity;
    }


    @Override
    public void deductMoney() {
        System.out.println("扣除50积分成功，您可以抽奖了");
        activity.setState(activity.getCanRaffleState());
    }

    @Override
    public boolean raffle() {
        System.out.println("扣了积分才能抽奖喔！");
        return false;
    }

    @Override
    public void dispensePrize() {
        System.out.println("不能发放奖品");
    }
}

public class CanRaffleState extends State{

    RaffleActivity activity;

    public CanRaffleState(RaffleActivity activity){
        this.activity = activity;
    }

    @Override
    public void deductMoney() {
        System.out.println("已经扣取过了积分");
    }

    @Override
    public void dispensePrize() {
        System.out.println("没中奖，不能发放奖品");
    }

    @Override
    public boolean raffle() {
        System.out.println("正在抽奖，请稍等！");
        Random random = new Random(10);
        int num= random.nextInt(10);
        if(num==3){
            activity.setState(activity.getDispenseState());
            return true;
        }else{
            System.out.println("很遗憾没有抽中奖品！");
            // 改变状态为不能抽奖
            activity.setState(activity.getNoRafflleState());
            return false;
        }
    }
}

public class DispenseState extends State {

    RaffleActivity activity;

    public DispenseState(RaffleActivity activity){
        this.activity = activity;
    }

    @Override
    public void deductMoney() {
        System.out.println("不能扣除积分");
    }

    @Override
    public boolean raffle() {
        System.out.println("不能抽奖");
        return false;
    }

    @Override
    public void dispensePrize() {
        if(activity.getCount() > 0){
            System.out.println("恭喜中奖了");
            // 改变状态为不能抽奖
            activity.setState(activity.getNoRafflleState());
        }else{
            System.out.println("很遗憾，奖品发送完了");
            // 改变状态为奖品发送完毕, 后面我们就不可以抽奖
            activity.setState(activity.getDispensOutState());
            //System.out.println("抽奖活动结束");
            //System.exit(0);
        }
    }
}

public class DispenseOutState extends State{

    RaffleActivity activity;

    public DispenseOutState(RaffleActivity activity){
        this.activity = activity;
    }

    @Override
    public void deductMoney() {
        System.out.println("奖品发送完了，请下次再参加");
    }

    @Override
    public boolean raffle() {
        System.out.println("奖品发送完了，请下次再参加");
        return false;
    }

    @Override
    public void dispensePrize() {
        System.out.println("奖品发送完了，请下次再参加");
    }
}

public class ClientTest {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        // 创建活动对象，奖品有1个奖品
        RaffleActivity activity = new RaffleActivity(1);

        // 我们连续抽300次奖
        for (int i = 0; i < 300; i++) {
            System.out.println("--------第" + (i + 1) + "次抽奖----------");
            // 参加抽奖，第一步点击扣除积分
            activity.debuctMoney();

            // 第二步抽奖
            activity.raffle();
        }
    }
}
```

# 策略模式

> 将项目中变化的部分使用组合/聚合的方式

## UML图

![image-20200627161521633](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200627161521633.png)

## 代码

```java
public abstract class Strategy {

    FlyBehavior flyBehavior;

    abstract void display();

    public void quack(){
        System.out.println("鸭子嘎嘎叫");
    }

    public void swim(){
        System.out.println("鸭子学会游泳");
    }

    public void fly(){
        if(flyBehavior!=null){
            flyBehavior.fly();
        }
    }
}

public interface FlyBehavior {
    void fly();
}

public class GoodFlyBehavior implements FlyBehavior {

    @Override
    public void fly() {
        System.out.println("我能飞翔得很好");
    }
}

public class WildDuck extends Strategy {

    public WildDuck(){
        this.flyBehavior = new GoodFlyBehavior();
    }

    @Override
    void display() {
        System.out.println("我是野鸭子");
    }
}


public class Client {
    public static void main(String[] args) {
        Strategy  toyDuck = new ToyDuck(); //代码基本相同 以WildDuck为准即可copy
        toyDuck.fly();

        Strategy pekingDuck = new PekingDuck();
        pekingDuck.fly();

        Strategy wildDuck = new WildDuck();
        wildDuck.fly();
    }

}

```

## 源码分析

```java
public class Strategy {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//数组
		Integer[] data = { 9, 1, 2, 8, 4, 3 };
		// 实现降序排序，返回-1放左边，1放右边，0保持不变
		
		// 说明
		// 1. 实现了 Comparator 接口（策略接口） , 匿名类 对象 new Comparator<Integer>(){..}
		// 2. 对象 new Comparator<Integer>(){..} 就是实现了 策略接口 的对象
		// 3. public int compare(Integer o1, Integer o2){} 指定具体的处理方式
		Comparator<Integer> comparator = new Comparator<Integer>() {
			public int compare(Integer o1, Integer o2) {
				if (o1 > o2) {
					return -1;
				} else {
					return 1;
				}
			};
		};
		
		// 说明
		/*
		 * public static <T> void sort(T[] a, Comparator<? super T> c) {
		        if (c == null) {
		            sort(a); //默认方法
		        } else { 
		            if (LegacyMergeSort.userRequested)
		                legacyMergeSort(a, c); //使用策略对象c
		            else
		            	// 使用策略对象c
		                TimSort.sort(a, 0, a.length, c, null, 0, 0);
		        }
		    }
		 */
		//方式1 
		Arrays.sort(data, comparator);
		
		System.out.println(Arrays.toString(data)); // 降序排序

		
		//方式2- 同时lambda 表达式实现 策略模式
		Integer[] data2 = { 19, 11, 12, 18, 14, 13 };
		
		Arrays.sort(data2, (var1, var2) -> {
			if(var1.compareTo(var2) > 0) {
				return -1;
			} else {
				return 1;
			}
		});
		
		System.out.println("data2=" + Arrays.toString(data2));
		
	}

}
```



# 责任链模式

> 将请求和处理分开,实现解耦,提高系统的灵活性

## UML图

![image-20200627174858222](C:\Users\xuehy\AppData\Roaming\Typora\typora-user-images\image-20200627174858222.png)

## 代码

```java
public class PurchaseRequest {

    float price;//价格

    int  type;//类型

    public PurchaseRequest(float price, int type) {
        this.price = price;
        this.type = type;
    }

    public float getPrice() {
        return price;
    }

    public int getType() {
        return type;
    }
}

public abstract  class Approver {

    Approver approver;

    String name;

    public Approver(String name){
        this.name = name;
    }

    public abstract void processRequest(PurchaseRequest purchaseRequest);

    public void setApprover(Approver approver) {
        this.approver = approver;
    }
}

public class CollegeApprover extends Approver {

    public CollegeApprover(String name) {
        super(name);
    }

    @Override
    public void processRequest(PurchaseRequest purchaseRequest) {
        if(purchaseRequest.getPrice()>5000){
            System.out.println(" 请求类型 type= " + purchaseRequest.getType() + " 被 " + this.name + " 处理");
        }else{
            approver.processRequest(purchaseRequest);
        }
    }
}

public class DepartmentApprover extends Approver {

    public DepartmentApprover(String name) {
        super(name);
    }

    @Override
    public void processRequest(PurchaseRequest purchaseRequest) {
        if(purchaseRequest.getPrice()<5000){
            System.out.println(" 请求类型 type= " + purchaseRequest.getType() + " 被 " + this.name + " 处理");
        }else{
            approver.processRequest(purchaseRequest);
        }
    }
}

public class Client {
    public static void main(String[] args) {
        PurchaseRequest purchaseRequest = new PurchaseRequest(6000.0f,1);
        DepartmentApprover departmentApprover = new DepartmentApprover("张主任");
        CollegeApprover collegeApprover = new CollegeApprover("李主任");
        departmentApprover.setApprover(collegeApprover);
        collegeApprover.setApprover(departmentApprover);

        departmentApprover.processRequest(purchaseRequest);

    }
}
```

## 源码分析

```java
public class ResponsibilityChain {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		// DispatcherServlet 
		
		//说明
		/*
		 * 
		 *  protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
		 *   HandlerExecutionChain mappedHandler = null; 
		 *   mappedHandler = getHandler(processedRequest);//获取到HandlerExecutionChain对象
		 *    //在 mappedHandler.applyPreHandle 内部 得到啦 HandlerInterceptor interceptor
		 *    //调用了拦截器的  interceptor.preHandle
		 *   if (!mappedHandler.applyPreHandle(processedRequest, response)) {
					return;
				}
				
			  //说明：mappedHandler.applyPostHandle 方法内部获取到拦截器，并调用 
			  //拦截器的  interceptor.postHandle(request, response, this.handler, mv);
			 mappedHandler.applyPostHandle(processedRequest, response, mv);
		 *  }
		 *  
		 *  
		 *  //说明：在  mappedHandler.applyPreHandle内部中，
		 *  还调用了  triggerAfterCompletion 方法，该方法中调用了  
		 *  HandlerInterceptor interceptor = getInterceptors()[i];
			try {
				interceptor.afterCompletion(request, response, this.handler, ex);
			}
			catch (Throwable ex2) {
				logger.error("HandlerInterceptor.afterCompletion threw exception", ex2);
			}
		 */
	
	}

}
```

