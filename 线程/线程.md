# 多线程的并发与并行

​	并行是指两个或者多个事情在同一时刻发生,并发是指两个或者多个事件在同一时间间隔发生

​	并行是在不同实体上的多个事件，并发是指在同一实体上的多个事件

​	在一台机器上同时"处理"多个任务,在多台机器上同时处理多个任务

# synchronize

   锁的是对象不是代码

   锁定方法可以和非锁定的方法同同时执行

   synchronized保证数据的可见性和原子性

```java
public class ThreadDemo3 implements Runnable {
    //volatile只是保证数据的可见性
    private /*volatile*/ int count = 10;
    //synchronized保证数据的可见性和原子性
    @Override
    public synchronized void run() {
        count--;
        System.out.println(Thread.currentThread().getName() + "count=" + count);
    }
    public static void main(String[] args) {
        ThreadDemo3 threadDemo3 = new ThreadDemo3();
        for (int i = 0; i < 5; i++) {
            new Thread(threadDemo3, "Thread" + i).start();
        }
    }
}
```

执行结果

```java
Connected to the target VM, address: '127.0.0.1:57901', transport: 'socket'
Thread2count=9
Thread0count=8
Thread4count=7
Thread3count=6
Thread1count=5
Disconnected from the target VM, address: '127.0.0.1:57901', transport: 'socket
```

```java
public class ThreadDemo3 implements Runnable {
    //volatile只是保证数据的可见性
    private volatile int count = 10;
    @Override
    public  void run() {
        count--;
        System.out.println(Thread.currentThread().getName() + "count=" + count);
    }
    public static void main(String[] args) {
        ThreadDemo3 threadDemo3 = new ThreadDemo3();
        for (int i = 0; i < 5; i++) {
            new Thread(threadDemo3, "Thread" + i).start();
        }
    }
}
```

执行结果

```java
Thread2count=8
Thread4count=7
Thread0count=8
Thread1count=6
Thread3count=5
//并不能保证数据的原子性
```

# synchronize锁优化

## 	锁的细化

​    

```java
//锁的细化
public class FineCoarseLock {
    int count = 0;

    void run() {
        //这里是要处理的业务逻辑,这里使用sleep来代替
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //当只有这里是有共享数据,将锁加载这 而不是加在 synchronized void run()上
        synchronized(this){
            count++;
        }
        //这里是要处理的业务逻辑,这里使用sleep来代替
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```



##      锁的粗化

# 锁升级:

##     偏向锁

​		线程来之后不加锁,记录线程id。下次再有线程进来时，认为这是上一次来的线程，如果还是上次的线程就继续运行不考虑加锁的问题。如果新的线程不是原来的线程进行锁升级；

##     自旋锁

​		使用场景(执行时间短，线程少，使用自旋锁)

​		当有线程将对象锁住之后,自旋锁在外面不断徘徊判断是否能拿到这个锁，当自旋10圈之后还拿不到，执行锁升级；

##     重量级锁

​		使用场景(执行时间长,线程多,使用os锁)

​	    经过os进入等待队列里

# volatile

​    	 作用:保证线程可见性 禁止指令重排序

​          可见性的实现:缓存一致性

 		 指令重排序实现:添加内存屏障

```java
public class VolatileDemo {
	//当不使用volatile时，永远执行不到end
    /*volatile*/ boolean running = true;

    void run() {
        System.out.println("start");
        while (running) {
        }
        System.out.println("end");
    }

    public static void main(String[] args) throws InterruptedException {
        VolatileDemo volatileDemo = new VolatileDemo();
        new Thread(volatileDemo::run).start();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        volatileDemo.running = false;
    }
} 	
```

执行结果

```java
start
```

# CAS (乐观锁)

  cas(obj,except,newValue):obj当前对象 except:期望值 newValue:新值 

  compare and swap:数据交换比较，如果期望值与新值不一致执行比较替换

##  ABA

  	当多个线程范访问时,当A线程需要修改1的值为2时，此时B线程刚好拿到值把1改为了3，C线程又把3改为1.此时A线程就会出现所谓的ABA问题。解决此问题的方法是添加一个版本号，或者时间戳。

# 不同加锁机制执行效率

```java
//不同锁的执行效率比比较
public class AtomicIntegerDemo1 {
    //CAS锁
    private static AtomicInteger count2 = new AtomicInteger(0);
    //加synchronized 相当于悲观锁 效率低
    private static long count1 = 0;
    //CAS+分段锁 当执行的线程比较大的时候,效率高
    private static LongAdder conut3 = new LongAdder();

    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[1000];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                for (int k = 0; k < 1000000; k++) count2.incrementAndGet();
            });
        }
        long start = System.currentTimeMillis();
        for (Thread t : threads) t.start();
        for (Thread t : threads) t.join();
        long end = System.currentTimeMillis();
        System.out.println("Atomic:" + count2.get() + "time:" + (end - start));

        //----------------
        Object lock = new Object();
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                for (int k = 0; k < 1000000; k++) {
                    synchronized (lock) {
                        count1++;
                    }
                }
            });
        }
        start = System.currentTimeMillis();
        for (Thread t : threads) t.start();
        for (Thread t : threads) t.join();
        end = System.currentTimeMillis();
        System.out.println("Long:" + count2.get() + "time:" + (end - start));

        // ------------------
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                for (int k = 0; k < 1000000; k++) conut3.increment();
            });
        }
        start = System.currentTimeMillis();
        for (Thread t : threads) t.start();
        for (Thread t : threads) t.join();
        end = System.currentTimeMillis();
        System.out.println("LongAdder:" + count2.get() + "time:" + (end - start));
    }
}
```

执行结果

```java
Atomic:1000000000time:27160
Long:1000000000time:37925
LongAdder:1000000000time:7319
```

# 可重入锁

​       当同一个线程进入A,B不同方法时(假设先进入A)，进入B是不需要重复加锁的。

```java
//可重入锁
public class ReentrantLock1 {

    synchronized void method1() {
        for (int i = 0; i < 10; i++) {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(i);
            if (i == 2) {
                //当metho1进入到method2时，是同一个线程 所以不需要加锁 直接可以进行访问
                method2();
            }
        }
    }

    synchronized void method2() {
        System.out.println("m2");
    }

    public static void main(String[] args) {
        ReentrantLock1 reentrantLock1 = new ReentrantLock1();
        new Thread(reentrantLock1::method1).start();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //new Thread(() -> reentrantLock1.method2()).start();
    }
}
```

# ReentrantLock

​      需要手动解加解锁

##  	使用案例1

```java
public class ReentrantLockDemo {

    private ReentrantLock lock = new ReentrantLock();
    private int count = 0;

    void run() {
        for (int i = 0; i < 100; i++) {
            //使用的是CAS结构
            lock.lock();//相当于synchronized,只不过需要释放锁
            try {
                count++;
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        ReentrantLockDemo reentrantLockDemo = new ReentrantLockDemo();
        Thread[] threads = new Thread[30];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(reentrantLockDemo::run);
        }
        for (Thread thread : threads) {
            try {
                thread.start();
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(reentrantLockDemo.count);
    }

}
```

## 	使用案例2

```java
public class ReentrantLockDemo1 {

    //添加一个公平锁的机制,使得每个线程在队列中进行等待,如果为false 按照本例子中会将线程1全部打完才会打印线程2
    ReentrantLock reentrantLock = new ReentrantLock(true);

    void run() {
        for (int i = 0; i < 10; i++) {
            try {
                reentrantLock.lock();
                System.out.println(Thread.currentThread().getName() + "获得锁");
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                reentrantLock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        ReentrantLockDemo1 reentrantLockDemo1 = new ReentrantLockDemo1();
        new Thread(reentrantLockDemo1::run).start();
        new Thread(reentrantLockDemo1::run).start();
    }
}
```

​	执行结果

```java
Thread-0获得锁
Thread-0获得锁
Thread-0获得锁
Thread-0获得锁
Thread-0获得锁
Thread-1获得锁
Thread-0获得锁
Thread-1获得锁
Thread-0获得锁
Thread-1获得锁
Thread-0获得锁
Thread-1获得锁
Thread-1获得锁
....
```

## 	使用案例3

```java
public class ReentrantLockDemo2 {

    ReentrantLock reentrantLock = new ReentrantLock();

    void method1() {

        try {
            reentrantLock.lock();
            for (int i = 0; i < 2; i++) {
                TimeUnit.SECONDS.sleep(1);
                System.out.println(i);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            reentrantLock.unlock();
        }
    }

    void method() {
        try {
            //尝试3s是否能拿到锁
            boolean bool = reentrantLock.tryLock(3, TimeUnit.SECONDS);
            if (bool) {
                System.out.println("拿到了");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            reentrantLock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ReentrantLockDemo2 reentrantLockDemo2 = new ReentrantLockDemo2();
        new Thread(reentrantLockDemo2::method1).start();
        Thread.sleep(1000);
        new Thread(reentrantLockDemo2::method).start();
    }
}
```

# CountDownLatch

```java
public class CountDownLatchDemo {

    private static ReentrantLock lock = new ReentrantLock();
    private static CountDownLatch countDownLatch = new CountDownLatch(30);
    private static int count = 0;

    static void run() {
        for (int i = 0; i < 99; i++) {
            //使用的是CAS结构
            lock.lock();//相当于synchronized,只不过需要释放锁
            try {
                count++;
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        Thread[] threads = new Thread[30];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                run();
                countDownLatch.countDown();
            });
        }
        for (Thread t : threads) {
            t.start();
        }
        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(count);
    }
}
```

# CyclicBarrier

```java
public class CyclicBarrierDemo {
    static CyclicBarrier cyclicBarrier = new CyclicBarrier(20, () -> System.out.println("当前线程数满20,可以运行了"));

    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                try {
                    cyclicBarrier.await();
//                    System.out.println("当前线程数满20,可以运行了");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

# Phaser（了解）



# ReadWriteLock

​	互斥锁也叫排他锁

```java
//读写锁
public class ReadWriteLockDemo {
    private static ReentrantLock lock = new ReentrantLock();
    //定义读写锁类
    private static ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    //定义读锁
    private static Lock readlock = readWriteLock.readLock();
    //定义写锁
    private static Lock writelock = readWriteLock.writeLock();
    private static int value;

    static void read(Lock lock) {
        try {
            lock.lock();
            Thread.sleep(1000);
            System.out.println("read lock");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    static void write(Lock lock, int val) {
        try {
            lock.lock();
            Thread.sleep(1000);
            value = val;
            System.out.println("write lock");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        //当使用lock时,执行需要一条一条的执行
//        Runnable readR = () -> read(lock);
//        Runnable wirteR = () -> write(lock, new Random().nextInt());
        //当使用readlock 和 writelock时候,一次性读取
        Runnable readR = () -> read(readlock);
        Runnable wirteR = () -> write(writelock, new Random().nextInt());
        for (int i = 0; i < 20; i++) new Thread(readR).start();
        for (int i = 0; i < 2; i++) new Thread(wirteR).start();
    }
}
```

# SEMAPHORE（信号灯）

```java
//灯塔
public class SemaphoreDemo {
    //最多运行1个线程同时运行
    static Semaphore semaphore = new Semaphore(1);
	
    static void method1() {
        try {
            semaphore.acquire();
            Thread.sleep(5000);
            System.out.println("执行线程一");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }

    static void method2() {
        try {
            semaphore.acquire();
            Thread.sleep(5000);
            System.out.println("线程二");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }

    public static void main(String[] args) {
        //当执行1线程之后，过五秒打印“线程一” 在过5s打印“线程二” 如果 new Semaphore(2);的话 过5s打印 “线程一” 
        //“线程二” 
        new Thread(SemaphoreDemo::method1).start();
        new Thread(SemaphoreDemo::method2).start();
    }
}
```

# EXCHANGER

```java
public class ExchangeLockDemo {
    static Exchanger<String> exchanger = new Exchanger();

    static void method1() {
        try {
            String t1 = exchanger.exchange("T1");
            Thread.sleep(2000);
            System.out.println(t1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    static void method2() {
        try {
            String t2 = exchanger.exchange("T2");
            Thread.sleep(2000);
            System.out.println(t2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        new Thread(ExchangeLockDemo::method1, "T1").start();
        new Thread(ExchangeLockDemo::method2, "T2").start();
    }

}
```

执行结果

```java
T2 //T1线程打印的值变为T2了
T1 //T2线程打印的值变为T1了

```

# LockSupport

> 类似于notify/wait
>
> 区别在于：在调用notify/wait必须先获得锁对象，但是park不需要获得对象锁就可以锁住对象
>
> notify只能随机唤醒任意一个线程,但是unpark可以唤醒执行线程

```java
public class LockSupportDemo {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                try {
                    TimeUnit.SECONDS.sleep(1);
                    System.out.println(i);
                    if (i == 6) {
                        LockSupport.park();
                    }
                    if (i == 8) {
                        LockSupport.park();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        t1.start();
        //能让第一次LockSupport.park();失效
        LockSupport.unpark(t1);
    }
}
```

执行结果

```java
0
1
2
3
4
5
6
7
8
//第二次执行LockSupport.park();拦截下来 走不到9
```

# 案例

## 	例子1

>  				两个线程,当一个线程数字到5时输出另外一个线程的值后，在继续打印
>  				//2020/07/05 注意如果是使用wait/notify的话需要注意两个线程是不是锁的是同一个对象 如果锁的不是同一个对象会有问题
>

```java
//多种实现方法 本案例中菜采取CountDownLatch的await与countdown实现
public class ThreadDemo4 {

    static List list = new ArrayList<>();

    private static CountDownLatch lock1 = new CountDownLatch(1);
    private static CountDownLatch lock2 = new CountDownLatch(1);
    private static Object obj = new Object();
    private static ReentrantLock lock = new ReentrantLock();

    static Thread t1 = null, t2 = null;

    public static void main(String args[]) {

        Runnable r = new Runnable() {
            @Override
            public void run() {
                synchronized (obj) {
                    for (int i = 0; i < 10; i++) {
                        list.add(i);
                        System.out.println(i);
                        if (list.size() == 5) {
                            //让线程2执行
                            lock1.countDown();
                            try {
//                                lock.lock();
                                lock2.await();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
//                        LockSupport.unpark(t2);
//                        LockSupport.park();
                        }
                    }
                }
            }
        };
        t1 = new Thread(r, "线程1");
        t2 = new Thread(() -> {
            synchronized (ThreadDemo4.class) {
                System.out.println("先执行我");
                if (list.size() != 5) {
                    try {
                        lock1.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("结束");
                lock2.countDown();
//                LockSupport.unpark(t1);
            }
        }, "线程T2");
        t2.start();
        t1.start();
    }
}
```



## 	例子2

​         生产者消费者的问题

```java
//多种实现方法,使用wait+notifyAll 可以参考注解后的代码
public class ThreadDemo5<T> {
    //生产者和消费者问题
    final LinkedList<T> list = new LinkedList<T>();
    static final private int MAX = 10;//最多存放的元素
    private Lock lock = new ReentrantLock();
    private Condition producer = lock.newCondition();
    private Condition consumer = lock.newCondition();
    private int count = 0;

    //生产者的
    void productor(T t) {
        lock.lock();
        try {
            while (list.size() == MAX) {
                try {
//                    this.wait();
                    producer.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            list.add(t);
            ++count;
//            this.notifyAll();
            consumer.signalAll();
            System.out.println("生产了" + count + "个");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    //消费者的
    synchronized void consumer() {
        lock.lock();
        try {
            while (list.size() == 0) {
                try {
//                    this.wait();
                    consumer.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = list.removeFirst();
            count--;
//            this.notifyAll();
            producer.signalAll();
            System.out.println("还剩" + count + "个");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        ThreadDemo5<String> demo5 = new ThreadDemo5();

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                while (true) {
                    demo5.consumer();
                }
            }, "C" + i).start();
        }

        for (int i = 0; i < 2; i++) {
            new Thread(() -> {
                while (true) {
                    demo5.productor(Thread.currentThread().getName());
                }
            }, "P" + i).start();
        }
    }

}
```



##        练习

​         两个线程交替打印A1B2C3

```java
public class ThreadDemo6 {

    private int flag = 1;

    public void showNum() {
        for (int i = 1; i <= 26; i++) {
            synchronized (this) {
                if (flag != 1) {
                    try {
                        this.wait();//等待
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.print(i + ",");
                flag = 0;
                this.notify();
            }
        }
    }

    public void showChar() {
        for (int i = 0; i < 26; i++) {
            synchronized (this) {
                if (flag != 0) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.print((char) (i + 'a') + ",");
                flag = 1;
                this.notify();
            }
        }
    }

    //两个线程交替打印A1B2C3
    public static void main(String[] args) {
        ThreadDemo6 threadDemo6 = new ThreadDemo6();
        new Thread(threadDemo6::showChar).start();
        new Thread(threadDemo6::showNum).start();
    }
}
```

```java
public class T02_00_LockSupport {


    static Thread t1 = null, t2 = null;

    public static void main(String[] args) throws Exception {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        t1 = new Thread(() -> {

                for(char c : aI) {
                    System.out.print(c);
                    LockSupport.unpark(t2); //叫醒T2
                    LockSupport.park(); //T1阻塞
                }

        }, "t1");

        t2 = new Thread(() -> {

            for(char c : aC) {
                LockSupport.park(); //t2阻塞
                System.out.print(c);
                LockSupport.unpark(t1); //叫醒t1
            }

        }, "t2");

        t1.start();
        t2.start();
    }
}
```

```java
public class T06_00_sync_wait_notify {
    public static void main(String[] args) {
        final Object o = new Object();

        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        new Thread(() -> {
            synchronized (o) {
                for (char c : aI) {
                    System.out.print(c);
                    try {
                        o.notify();
                        o.wait(); //让出锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                o.notify(); //必须，否则无法停止程序
            }

        }, "t1").start();

        new Thread(() -> {
            synchronized (o) {
                for (char c : aC) {
                    System.out.print(c);
                    try {
                        o.notify();
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                o.notify();
            }
        }, "t2").start();
    }
}
```

```java
public class T04_00_BlockingQueue {


    static BlockingQueue<String> q1 = new ArrayBlockingQueue(1);
    static BlockingQueue<String> q2 = new ArrayBlockingQueue(1);

    public static void main(String[] args) throws Exception {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        new Thread(() -> {

            for(char c : aI) {
                System.out.print(c);
                try {
                    q1.put("ok");
                    q2.take();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        }, "t1").start();

        new Thread(() -> {

            for(char c : aC) {
                try {
                    q1.take();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.print(c);
                try {
                    q2.put("ok");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        }, "t2").start();


    }
}
```



# 容器

## Collection

### 					List

#### CopyOnWriteArrayList

​		      写的时候添加锁,读的时候不添加锁 读多写少的时候使用	

```java
public class T02_CopyOnWriteList {
	public static void main(String[] args) {
		List<String> lists = 
				//new ArrayList<>(); //这个会出并发问题！
				//new Vector();
				new CopyOnWriteArrayList<>();
		Random r = new Random();
		Thread[] ths = new Thread[100];
		
		for(int i=0; i<ths.length; i++) {
			Runnable task = new Runnable() {
	
				@Override
				public void run() {
					for(int i=0; i<1000; i++) lists.add("a" + r.nextInt(10000));
				}
				
			};
			ths[i] = new Thread(task);
		}
		
		
		runAndComputeTime(ths);
		
		System.out.println(lists.size());
	}
	
	static void runAndComputeTime(Thread[] ths) {
		long s1 = System.currentTimeMillis();
		Arrays.asList(ths).forEach(t->t.start());
		Arrays.asList(ths).forEach(t->{
			try {
				t.join();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		});
		long s2 = System.currentTimeMillis();
		System.out.println(s2 - s1);
		
	}
}
```



### Set

####      Queue

```
 添加了对线程很多友好的API 

​		 offer:相当于list的add,添加成功返回true

​		 peek:取完不会remove

​		 poll:取并且remove
```

##### 			linkedBlockingQueue

```
无界的链表,直至内存不足

​		    put ：往里装，如果满了 阻塞

​			take : 往里拿 ，如果没有值,阻塞 

​			相当于生产者消费者模型
```

```java
public class T05_LinkedBlockingQueue {

	static BlockingQueue<String> strs = new LinkedBlockingQueue<>();

	static Random r = new Random();

	public static void main(String[] args) {
		new Thread(() -> {
			for (int i = 0; i < 100; i++) {
				try {
					strs.put("a" + i); //如果满了，就会等待
					TimeUnit.MILLISECONDS.sleep(r.nextInt(1000));
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}, "p1").start();

		for (int i = 0; i < 5; i++) {
			new Thread(() -> {
				for (;;) {
					try {
						System.out.println(Thread.currentThread().getName() + " take -" + strs.take()); //如果空了，就会等待
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}, "c" + i).start();

		}
	}
}
```

##### 		     ConcurrentLinkedQueue

> ConcurrentLinkedQueue的属性说明

```java
public class T04_ConcurrentQueue {
	public static void main(String[] args) {
		Queue<String> strs = new ConcurrentLinkedQueue<>();
		
		for(int i=0; i<10; i++) {
			strs.offer("a" + i);  //等同于list中的add
		}
		
		System.out.println(strs);
		
		System.out.println(strs.size());
		
		System.out.println(strs.poll());//取出第一个并且删除这个元素
		System.out.println(strs.size());
		
		System.out.println(strs.peek());//取出这个元素
		System.out.println(strs.size());
		
		//双端队列Deque
	}
}
```

##### 	     	Delayqueue	

> 定时任务

```java
public class T07_DelayQueue {

	static BlockingQueue<MyTask> tasks = new DelayQueue<>();

	static Random r = new Random();
	
	static class MyTask implements Delayed {
		String name;
		long runningTime;
		
		MyTask(String name, long rt) {
			this.name = name;
			this.runningTime = rt;
		}

		@Override
		public int compareTo(Delayed o) {
			if(this.getDelay(TimeUnit.MILLISECONDS) < o.getDelay(TimeUnit.MILLISECONDS))
				return -1;
			else if(this.getDelay(TimeUnit.MILLISECONDS) > o.getDelay(TimeUnit.MILLISECONDS)) 
				return 1;
			else 
				return 0;
		}

		@Override
		public long getDelay(TimeUnit unit) {
			
			return unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);
		}
		
		
		@Override
		public String toString() {
			return name + " " + runningTime;
		}
	}

	public static void main(String[] args) throws InterruptedException {
		long now = System.currentTimeMillis();
		MyTask t1 = new MyTask("t1", now + 1000);
		MyTask t2 = new MyTask("t2", now + 2000);
		MyTask t3 = new MyTask("t3", now + 1500);
		MyTask t4 = new MyTask("t4", now + 2500);
		MyTask t5 = new MyTask("t5", now + 500);
		
		tasks.put(t1);
		tasks.put(t2);
		tasks.put(t3);
		tasks.put(t4);
		tasks.put(t5);
		
		System.out.println(tasks);
		
		for(int i=0; i<5; i++) {
			System.out.println(tasks.take());
		}
	}
}

```

##### 	     	priorityQueue

```java
public class T07_01_PriorityQueque {
    public static void main(String[] args) {
        PriorityQueue<String> q = new PriorityQueue<>();

        q.add("c");
        q.add("e");
        q.add("a");
        q.add("d");
        q.add("z");

        for (int i = 0; i < 5; i++) {
            System.out.println(q.poll());
        }

    }
}
```

##### 		 	synchronousQueue

```
线程容量为0,无法往线程中添加内容
```

```java
public class T08_SynchronusQueue { //容量为0
	public static void main(String[] args) throws InterruptedException {
		BlockingQueue<String> strs = new SynchronousQueue<>();
		
		new Thread(()->{
			try {
				System.out.println(strs.take());
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}).start();

		strs.put("aaa"); //阻塞等待消费者消费
		//strs.put("bbb");
		//strs.add("aaa");
		System.out.println(strs.size());
	}
}
```

##### 	     	transferQueue

```
transfer 方法
作用:确认线程有人取走，才结束当前线程
```

```java
public class T09_TransferQueue {
	public static void main(String[] args) throws InterruptedException {
		LinkedTransferQueue<String> strs = new LinkedTransferQueue<>();
		
		new Thread(() -> {
			try {
				System.out.println(strs.take());
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}).start();
		
		strs.transfer("aaa");
		
		//strs.put("aaa");


		/*new Thread(() -> {
			try {
				System.out.println(strs.take());
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}).start();*/

	}
}
```

### 	Map

#### 	HashTable

#### 	HashMap

#### 	synchronizedMap

#### 		correntHashMap

> 线程安全的:HashTable synchronizedMap correntHashMap
> 线程不安全的:HashMap

> 以下是使用不同的map进行高并发是否安全的案例

```java
public class T03_TestSynchronizedHashMap {
	//修改相应的map类型即可
    static Map<UUID, UUID> m = Collections.synchronizedMap(new HashMap<UUID, UUID>());

    static int count = Constants.COUNT;
    static UUID[] keys = new UUID[count];
    static UUID[] values = new UUID[count];
    static final int THREAD_COUNT = Constants.THREAD_COUNT;

    static {
        for (int i = 0; i < count; i++) {
            keys[i] = UUID.randomUUID();
            values[i] = UUID.randomUUID();
        }
    }

    static class MyThread extends Thread {
        int start;
            int gap = count/THREAD_COUNT;

        public MyThread(int start) {
            this.start = start;
        }

        @Override
        public void run() {
            for(int i=start; i<start+gap; i++) {
                m.put(keys[i], values[i]);
            }
        }
    }

    public static void main(String[] args) {

        long start = System.currentTimeMillis();

        Thread[] threads = new Thread[THREAD_COUNT];

        for(int i=0; i<threads.length; i++) {
            threads[i] =
            new MyThread(i * (count/THREAD_COUNT));
        }

        for(Thread t : threads) {
            t.start();
        }

        for(Thread t : threads) {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        long end = System.currentTimeMillis();
        System.out.println(end - start);

        System.out.println(m.size());

        //-----------------------------------

        start = System.currentTimeMillis();
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(()->{
                for (int j = 0; j < 10000000; j++) {
                    m.get(keys[10]);
                }
            });
        }

        for(Thread t : threads) {
            t.start();
        }

        for(Thread t : threads) {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        end = System.currentTimeMillis();
        System.out.println(end - start);
    }
}
```

# Executor

## ExecutorService

### AbstractExecutorService

#### ThreadPoolExecutor(七个参数)

> corePoolSize：核心线程数
> maxPoolSize:最大线程数
> keepAliveTime：存活时间
> TimeUnit：时间单位
> BlockingQueue:任务队列
> ThreadFactory：线程工厂
> RejectStratege:拒绝策略  
> 	Abort
> 	DisCard:丢掉
> 	DisCardOld
> 	CallsRuns：谁提交的谁处理

> 简单的案例

```java
public class T05_00_HelloThreadPool {

    static class Task implements Runnable {
        private int i;

        public Task(int i) {
            this.i = i;
        }

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + " Task " + i);
            try {
                System.in.read();//阻塞
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        @Override
        public String toString() {
            return "Task{" +
                    "i=" + i +
                    '}';
        }
    }

    public static void main(String[] args) {
        ThreadPoolExecutor tpe = new ThreadPoolExecutor(2, 4,
                60, TimeUnit.SECONDS,
                new ArrayBlockingQueue<Runnable>(4),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardOldestPolicy());//谁给的当线程不够自己处理

        for (int i = 0; i < 8; i++) {
            tpe.execute(new Task(i));
        }

        System.out.println(tpe.getQueue());//在队列中等待的线程数

        tpe.execute(new Task(100));//队列都满了 main方法自己处理

        System.out.println("--"+tpe.getQueue());

        boolean shutdown = tpe.isShutdown();
        System.out.println(shutdown);
        tpe.shutdown();
    }
}
```

##### Executors

> 简单写了个小程序,使用Executors的用法

```java
public class T01_MyExecutor implements Executor{

	public static void main(String[] args) {
		new T01_MyExecutor().execute(()->System.out.println("hello executor"));
	}

	@Override
	public void execute(Runnable command) {
		new Thread(command).start();
	}

}
```

###### SingleThreadPool

> 启动一个只有一个线程的线程池工作

```java
public class T07_SingleThreadPool {
	public static void main(String[] args) {
		ExecutorService service = Executors.newSingleThreadExecutor();
		for(int i=0; i<100; i++) {
			final int j = i;
			service.execute(()->{
				
				System.out.println(j + " " + Thread.currentThread().getName());
			});
		}
	}
}
```

```Java
执行结果的线程名称
4 pool-1-thread-1
5 pool-1-thread-1
6 pool-1-thread-1
7 pool-1-thread-1
8 pool-1-thread-1
9 pool-1-thread-1
10 pool-1-thread-1
11 pool-1-thread-1
12 pool-1-thread-1
```

###### CachedPool

```java
public class T08_CachedPool {
	public static void main(String[] args) throws InterruptedException {
		ExecutorService service = Executors.newCachedThreadPool();
		//当前线程队列中的数
		System.out.println(service);
		for (int i = 0; i < 2; i++) {
			service.execute(() -> {
				try {
					TimeUnit.MILLISECONDS.sleep(500);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread().getName());
			});
		}
		//执行完两个线程之后当前线程的状态
		System.out.println(service);
		//证明当线程睡60L之后自动回收 newCachedThreadPool默认为60L回收线程
		TimeUnit.SECONDS.sleep(80);
		//这边线程已经自动回收
		System.out.println(service);
	}
}
```

```java
java.util.concurrent.ThreadPoolExecutor@60e53b93[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]
java.util.concurrent.ThreadPoolExecutor@60e53b93[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 0]
pool-1-thread-1
pool-1-thread-2
java.util.concurrent.ThreadPoolExecutor@60e53b93[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 2]

Process finished with exit code 0
```

###### FixedThreadPool

```java
public class T09_FixedThreadPool {
	public static void main(String[] args) throws InterruptedException, ExecutionException {
		long start = System.currentTimeMillis();
		getPrime(1, 200000); 
		long end = System.currentTimeMillis();
		System.out.println("启动主线程计算时间为:"+(end - start));
		
		final int cpuCoreNum = 4;
		
		ExecutorService service = Executors.newFixedThreadPool(cpuCoreNum);
		
		MyTask t1 = new MyTask(1, 80000); //1-5 5-10 10-15 15-20
		MyTask t2 = new MyTask(80001, 130000);
		MyTask t3 = new MyTask(130001, 170000);
		MyTask t4 = new MyTask(170001, 200000);
		
		Future<List<Integer>> f1 = service.submit(t1);
		Future<List<Integer>> f2 = service.submit(t2);
		Future<List<Integer>> f3 = service.submit(t3);
		Future<List<Integer>> f4 = service.submit(t4);
		
		start = System.currentTimeMillis();
		f1.get();
		f2.get();
		f3.get();
		f4.get();
		end = System.currentTimeMillis();
		System.out.println("启用线程池，计算时间为:"+(end - start));
	}
	
	static class MyTask implements Callable<List<Integer>> {
		int startPos, endPos;
		
		MyTask(int s, int e) {
			this.startPos = s;
			this.endPos = e;
		}
		
		@Override
		public List<Integer> call() throws Exception {
			List<Integer> r = getPrime(startPos, endPos);
			return r;
		}
		
	}
	
	static boolean isPrime(int num) {
		for(int i=2; i<=num/2; i++) {
			if(num % i == 0) return false;
		}
		return true;
	}
	
	static List<Integer> getPrime(int start, int end) {
		List<Integer> results = new ArrayList<>();
		for(int i=start; i<=end; i++) {
			if(isPrime(i)) results.add(i);
		}
		
		return results;
	}
}
```

###### ScheduledThreadPool

> 定时执行的一个线程池

```java
public class T10_ScheduledPool {
	public static void main(String[] args) {
		ScheduledExecutorService service = Executors.newScheduledThreadPool(4);
		service.scheduleAtFixedRate(()->{
			try {
				TimeUnit.MILLISECONDS.sleep(new Random().nextInt(1000));
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(Thread.currentThread().getName());
		}, 0, 500, TimeUnit.MILLISECONDS);
	}
}
```

## Forkjoin

> 分解汇总的任务

> 用很少的线程可以执行很多的任务(子任务)TPE做不到先执行子任务

> cpu密集性

### WorkStealingPool

> 暂时有什么作用不太清楚,本例先给个简单的案例
>

```java
public class T11_WorkStealingPool {
	public static void main(String[] args) throws IOException {
		ExecutorService service = Executors.newWorkStealingPool();
		System.out.println(Runtime.getRuntime().availableProcessors());

		service.execute(new R(1000));
		service.execute(new R(2000));
		service.execute(new R(2000));
		service.execute(new R(2000)); //daemon
		service.execute(new R(2000));
		
		//由于产生的是精灵线程（守护线程、后台线程），主线程不阻塞的话，看不到输出
		System.in.read();
	}

	static class R implements Runnable {

		int time;

		R(int t) {
			this.time = t;
		}

		@Override
		public void run() {
			
			try {
				TimeUnit.MILLISECONDS.sleep(time);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			System.out.println(time  + " " + Thread.currentThread().getName());
			
		}

	}
}
```

### parallelStream

> parallelStream的一个简单案例

```java
public class T13_ParallelStreamAPI {
	public static void main(String[] args) {
		List<Integer> nums = new ArrayList<>();
		Random r = new Random();
		for(int i=0; i<10000; i++) nums.add(1000000 + r.nextInt(1000000));
		
		//System.out.println(nums);
		
		long start = System.currentTimeMillis();
		nums.forEach(v->isPrime(v));
		long end = System.currentTimeMillis();
		System.out.println(end - start);
		
		//使用parallel stream api
		
		start = System.currentTimeMillis();
		nums.parallelStream().forEach(T13_ParallelStreamAPI::isPrime);
		end = System.currentTimeMillis();
		
		System.out.println(end - start);
	}
	
	static boolean isPrime(int num) {
		for(int i=2; i<=num/2; i++) {
			if(num % i == 0) return false;
		}
		return true;
	}
}
```

### ForkJoinPool

> ForkJoinPool的简单案例

```java
public class T12_ForkJoinPool {
	static int[] nums = new int[1000000];
	static final int MAX_NUM = 50000;
	static Random r = new Random();
	
	static {
		for(int i=0; i<nums.length; i++) {
			nums[i] = r.nextInt(100);
		}
		
		System.out.println("---" + Arrays.stream(nums).sum()); //stream api
	}
	

	static class AddTask extends RecursiveAction {

		int start, end;

		AddTask(int s, int e) {
			start = s;
			end = e;
		}

		@Override
		protected void compute() {

			if(end-start <= MAX_NUM) {
				long sum = 0L;
				for(int i=start; i<end; i++) sum += nums[i];
				System.out.println("from:" + start + " to:" + end + " = " + sum);
			} else {

				int middle = start + (end-start)/2;

				AddTask subTask1 = new AddTask(start, middle);
				AddTask subTask2 = new AddTask(middle, end);
				subTask1.fork();
				subTask2.fork();
			}


		}

	}

	static class AddTaskRet extends RecursiveTask<Long> {
		
		private static final long serialVersionUID = 1L;
		int start, end;
		
		AddTaskRet(int s, int e) {
			start = s;
			end = e;
		}

		@Override
		protected Long compute() {
			
			if(end-start <= MAX_NUM) {
				long sum = 0L;
				for(int i=start; i<end; i++) sum += nums[i];
				return sum;
			} 
			
			int middle = start + (end-start)/2;
			
			AddTaskRet subTask1 = new AddTaskRet(start, middle);
			AddTaskRet subTask2 = new AddTaskRet(middle, end);
			subTask1.fork();
			subTask2.fork();
			
			return subTask1.join() + subTask2.join();
		}
		
	}
	
	public static void main(String[] args) throws IOException {
		/*ForkJoinPool fjp = new ForkJoinPool();
		AddTask task = new AddTask(0, nums.length);
		fjp.execute(task);*/

		T12_ForkJoinPool temp = new T12_ForkJoinPool();

		ForkJoinPool fjp = new ForkJoinPool();
		AddTaskRet task = new AddTaskRet(0, nums.length);
		fjp.execute(task);
		long result = task.join();
		System.out.println(result);
		
		//System.in.read();
		
	}
}
```

## Callable

> 类似于Runnable但是有返回值

```java
public class T03_Callable {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Callable<String> c = new Callable() {
            @Override
            public String call() throws Exception {
                return "Hello Callable";
            }
        };

        FutureTask<String> future = new FutureTask<>(c);
        new Thread(future).start();
        System.out.println(future.get());
    }
}
```

## Future

> 存储将来执行的结果

### FutureTask

> 相当于Futue+Runnable

```java
public class T06_00_Future {
	public static void main(String[] args) throws InterruptedException, ExecutionException {
		FutureTask<Integer> task = new FutureTask<>(()->{
			TimeUnit.MILLISECONDS.sleep(500);
			return 1000;
		}); //new Callable () { Integer call();}
		new Thread(task).start();
		System.out.println(task.get()); //阻塞
	}
}
```

### completableFuture

> 用来管理多个future，不太了解含义

```java
public class T06_01_CompletableFuture {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        long start, end;

        /*start = System.currentTimeMillis();

        priceOfTM();
        priceOfTB();
        priceOfJD();

        end = System.currentTimeMillis();
        System.out.println("use serial method call! " + (end - start));*/

        start = System.currentTimeMillis();

        CompletableFuture<Double> futureTM = CompletableFuture.supplyAsync(()->priceOfTM());
        CompletableFuture<Double> futureTB = CompletableFuture.supplyAsync(()->priceOfTB());
        CompletableFuture<Double> futureJD = CompletableFuture.supplyAsync(()->priceOfJD());

        CompletableFuture.allOf(futureTM, futureTB, futureJD).join();

        CompletableFuture.supplyAsync(()->priceOfTM())
                .thenApply(String::valueOf)
                .thenApply(str-> "price " + str)
                .thenAccept(System.out::println);


        end = System.currentTimeMillis();
        System.out.println("use completable future! " + (end - start));

        try {
            System.in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static double priceOfTM() {
        delay();
        return 1.00;
    }

    private static double priceOfTB() {
        delay();
        return 2.00;
    }

    private static double priceOfJD() {
        delay();
        return 3.00;
    }

    /*private static double priceOfAmazon() {
        delay();
        throw new RuntimeException("product not exist!");
    }*/

    private static void delay() {
        int time = new Random().nextInt(500);
        try {
            TimeUnit.MILLISECONDS.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.printf("After %s sleep!\n", time);
    }
}
```

